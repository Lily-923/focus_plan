# 计算机视觉
## 计算机如何表示图像？图像看起来是否清晰与哪些因素有关？
计算机表示图像主要有两种方式：矢量图和位图。
- 矢量图：矢量图使用数学公式来描述图像，由点、线、曲线、多边形等几何元素组成。
- 位图（点阵图）：由像素组成，每个像素包含颜色信息，排列成网格状。位图数据通常是一个一维数组，按从左到右，从上到下的顺序排列像素值。
图像的清晰度受多种因素影响，主要包括：**分辨率**（图像包含的像素数量）、**像素密度**（每英寸像素数）、**位深度**（每个像素的颜色位数，位深度越高，颜色过渡越平滑）、**压缩质量**（高压缩可能导致图像失真）。
## 是否存在PSNR高，但是人眼看起来质量差的图像？你认为应该如何解决这种评估误差？
PSNR：**峰值信噪比**，用来量化两幅图之间的差异，PSNR越高，两幅图越接近，质量越好。
应该是存在的。因为PSNR只考虑了像素级均方误差，没有考虑人眼的视觉特性，比如人眼对边缘/结构比较敏感，但是对纹理噪声不敏感。
粗略地认为，**让机器学习人眼视觉系统的特性**，就可以减小这种误差。专业化一点应该就是把“深度学习感知特征”显式地量化进指标。
## 这是一个CV中的什么任务？简述该任务的技术发展，这个任务在现实中有何应用？
**图像去模糊---计算机视觉“图像复原”**下的一个子任务：给定模糊图像B，估计并恢复其对应的清晰图像I。
数学模型通常写成B=k⊕vI+n,其中k为模糊核（PSF），n为噪声，当k未知的时候称为盲去模糊，k已知是称为非盲去模糊。
技术发展：
1.频域滤波阶段（1960s-1980s）：将模糊视为卷积退化，提出逆滤波、维纳滤波等频域方法
2.正则化与先验优化阶段（1990s-2010）
3.深度学习萌芽阶段（2015-2017）：CNN
4.深度网络爆炸阶段（2018-2021）：开始探索更高频细节恢复
5.大模型与复杂场景阶段（2022-今）
图像去模糊可用于智能手机摄影、车载视觉、医学影像、无人机卫星遥感、档案修复等多个领域。
## 图像退化通常如何建模？常见的退化类型有哪些？
图形退化的通用建模思想是把“清晰原图”和“退化算子”写成可逆或不可逆的数学过程，从而用统一方程描述观测图像的生成。最经典的框架是线性退化模型：
g(x,y)=h(x,y)⊕f(x,y)+n(x,y)
其中：f(x,y):理想清晰图像
            h(x,y):退化核
            ⊕：二维卷积
            n(x,y):加性噪声
            g(x,y):观测到的退化图像
常见的退化类型：模糊（运动模糊、离焦模糊、高斯模糊）、镜噪声、降采样等等。
## 本题未提供训练数据，请简述一种合成退化图像-原图对的方法。你认为这种方式和实际退化情况的差距在哪？ 
**合成退化管线**自动生成配对。核心思想是：拿高分辨率、无失真的公开图像当“清晰原图”，按照可控顺序叠加已知退化算子，得到“伪真实”退化图。
具体顺序：选“干净原图”（尽量无失真、高分辨率）--生成模糊核（相当于数学模型里的h）--卷积生成模糊图（进行g=h⊕f的运算）--降采样（制造低分辨率）----加噪声（模拟传感器/传输误差）--压缩--批量输出。
真实的差距可能有：
- 模糊核的合成做法与真实情况造成的PSF有差距；
- 噪声模型过度简化；
- 退化顺序赫实际的耦合顺序可能不同；
- 场景内容偏差。
## 简述如何估计本题中图像的噪声类型？用什么方式验证自己的判断？
本题中的图片应该是从清晰图像加上马赛克的模糊图像。应该属于“人工降采样/像素化失真”。
验证：1.把图放大，看是否出现**整齐的N*N同色方块**
            2.利用**灰度直方图**。像素画直方图呈现**稀疏，离散的尖峰**，高斯/椒盐噪声的直方图连续且平滑。
![输入图片说明](/imgs/2025-08-09/F1ih3CUl6D4j9u58.png)
## 你觉得什么模型比较适合用来处理这个问题，什么模型不适合？
超分辨率+像素级约束+高频先验，无约束GAN（生成对抗网络）适合；纯去噪/去卷积、传统插值不适合。
## 什么是数据增强？请在你自己的数据集做一些数据增强用于数据训练。
数据增强是在不改变（或仅轻微改变）样本标签的前提下，通过对已有数据做各种“变形”或“加噪”，人为地造出更多、更丰富的训练样本，从而提高模型泛化能力，减轻过拟合。
## 所有代码
### 模型定义
```
import torch.nn as nn  
  
class ESPCN(nn.Module):  
    def __init__(self, scale=4):  
        super().__init__()  
        self.body = nn.Sequential(  
            nn.Conv2d(3, 64, 5, padding=2), nn.Tanh(),  
            nn.Conv2d(64, 32, 3, padding=1), nn.Tanh(),  
            nn.Conv2d(32, 3*scale*scale, 3, padding=1),  
            nn.PixelShuffle(scale)  
        )  
  
    def forward(self, x):  
        return self.body(x)
  ```
### 生成训练数据
```
  import cv2, random, os  
from pathlib import Path  
  
HR_DIR   = Path(r'D:\mosaic_sr\mosaic\demo_in\DIV2K_train_HR')  # 原高清  
OUT_DIR  = Path(r'D:\mosaic_sr\mosaic\data')                     # 训练数据  
OUT_DIR.mkdir(parents=True, exist_ok=True)  
SCALE = 4  
  
for img_path in HR_DIR.glob('*'):  
    hr = cv2.imread(str(img_path))  
    if hr is None:                # 防止空图  
        continue  
    # 生成 LR（马赛克）  
    h, w = hr.shape[:2]  
    lr   = cv2.resize(cv2.GaussianBlur(hr,(3,3),0), (w//SCALE, h//SCALE), interpolation=cv2.INTER_AREA)  
    # 保存成对  
    cv2.imwrite(str(OUT_DIR / f'{img_path.stem}_HR.png'), hr)  
    cv2.imwrite(str(OUT_DIR / f'{img_path.stem}_LR.png'), lr)  
    print(f"已生成：{img_path.name}")  
  
print("全部完成！")
```
### 推理
```
import torch  
import cv2  
import os  
from pathlib import Path  
from model.net import ESPCN   # 你的模型类  
  
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')  
  
1. 创建并加载模型  
model = ESPCN().to(device)  
state = torch.load(r'D:\mosaic_sr\mosaic\weights\best.ckpt', map_location=device)  
model.load_state_dict(state, strict=False)  
model.eval()  
  
 2. 单张推理函数  
def process_image(image_path, output_path):  
    img = cv2.imread(str(image_path))  
    if img is None:  
        print('读图失败：', image_path)  
        return  
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB).astype('float32') / 255.0  
    img = torch.from_numpy(img).permute(2, 0, 1).unsqueeze(0).to(device)  
  
    with torch.no_grad():  
        out = model(img).squeeze(0).permute(1, 2, 0).clamp(0, 1).cpu().numpy()  
    out = cv2.resize(out, (1000, 1000))  # ← 新增/修改  
    out = (out * 255).astype('uint8')  
    out = cv2.cvtColor(out, cv2.COLOR_RGB2BGR)  
  
3. 批量推理  
if __name__ == '__main__':  
    input_dir  = Path(r'D:\mosaic_sr\mosaic\JotangRecrument-main\JotangRecrument-main\ML\task_3\image_pairs\blurred')  
    output_dir = Path(r'D:\mosaic_sr\mosaic\results')  
    output_dir.mkdir(exist_ok=True)  
  
    for file in input_dir.glob('*.png'):  
        process_image(file, output_dir / file.name)  
  
    print('全部推理完成！结果保存在', output_dir)
```
### 训练
```
import cv2  
import torch  
from torch.utils.data import Dataset, DataLoader  
import torch.nn as nn  
import pytorch_lightning as pl  
from pathlib import Path  
from model.net import ESPCN  # 确保正确导入 ESPCN 类  
  
# 数据集类，读取数据  
class PairDataset(Dataset):  
    def __init__(self, root):  
        root = Path(root)  
        hr_files = sorted(root.glob('*_HR.png'))  
        lr_files = sorted(root.glob('*_LR.png'))  
        assert len(hr_files) == len(lr_files), f"HR 和 LR 文件数量不一致: HR({len(hr_files)}), LR({len(lr_files)})"  
        self.pairs = list(zip(lr_files, hr_files))  
        print(f"成功加载 {len(self.pairs)} 对训练样本")  
  
    def __len__(self):  
        return len(self.pairs)  
  
    def __getitem__(self, idx):  
        lr_path, hr_path = self.pairs[idx]  
        lr = cv2.imread(str(lr_path), cv2.IMREAD_COLOR)  
        hr = cv2.imread(str(hr_path), cv2.IMREAD_COLOR)  
        if lr is None or hr is None:  
            raise FileNotFoundError(f"无法读取图片: {lr_path} 或 {hr_path}")  
        lr = cv2.resize(lr, (128, 128))  
        hr = cv2.resize(hr, (512, 512))  
        lr = torch.from_numpy(lr[:, :, ::-1] / 255.0).permute(2, 0, 1).float()  
        hr = torch.from_numpy(hr[:, :, ::-1] / 255.0).permute(2, 0, 1).float()  
        return lr, hr  
  
# 模型  
class LitSR(pl.LightningModule):  
    def __init__(self):  
        super().__init__()  
        self.net = ESPCN(scale=4)  
  
    def forward(self, x):  
        return self.net(x)  
  
    def training_step(self, batch, idx):  
        lr, hr = batch  
        loss = nn.L1Loss()(self(lr), hr)  
        self.log('train_loss', loss)  
        return loss  
  
    def configure_optimizers(self):  
        return torch.optim.Adam(self.net.parameters(), lr=1e-3)  
  
if __name__ == '__main__':  
    data_dir = Path(r'D:\mosaic_sr\mosaic\data')  # 确保路径正确  
  
    ds = PairDataset(data_dir)  
    dl = DataLoader(ds, batch_size=8, shuffle=True, num_workers=4)  
  
    model = LitSR()  
    trainer = pl.Trainer(max_epochs=200, accelerator='auto')  
    trainer.fit(model, dl)  
    torch.save(model.state_dict(), 'weights/best.ckpt')  
    print("训练完成！")
```
### 输出PSNR
```
import os  
import cv2  
import numpy as np  
from skimage.metrics import peak_signal_noise_ratio  
  
gt_dir   = r'D:\mosaic_sr\mosaic\JotangRecrument-main\JotangRecrument-main\ML\task_3\image_pairs\original'   # 真值（原高清）  
pred_dir = r'D:\mosaic_sr\mosaic\JotangRecrument-main\JotangRecrument-main\ML\task_3\image_pairs\blurred'    # 推理结果  
  
psnr_list = []  
  
for i in range(1, 41):  
    filename = f'{i}.png'  
    gt_path = os.path.join(gt_dir, filename)  
    pred_path = os.path.join(pred_dir, filename)  
  
    gt_img = cv2.imread(gt_path)  
    pred_img = cv2.imread(pred_path)  
  
    if gt_img is None or pred_img is None:  
        print(f"Missing file: {filename}")  
        continue  
  
    gt_img = cv2.cvtColor(gt_img, cv2.COLOR_BGR2RGB)  
    pred_img = cv2.cvtColor(pred_img, cv2.COLOR_BGR2RGB)  
  
    if gt_img.shape != pred_img.shape:  
        print(f"Size mismatch: {filename}")  
        continue  
  
    psnr = peak_signal_noise_ratio(gt_img, pred_img, data_range=255)  
  
    print(f"{filename}: PSNR={psnr:.4f}")  
  
    psnr_list.append(psnr)  
  
if psnr_list:  
    avg_psnr = np.mean(psnr_list)  
    print(f"\nAverage PSNR: {avg_psnr:.4f}")  
else:  
    print("No valid images evaluated.")
 ```
 ### 训练过程
![输入图片说明](/imgs/2025-08-29/bApruEaq34hrz7Bw.jpeg)### PSNR
![输入图片说明](/imgs/2025-08-29/rNJ3JpwC1PL7ZKzu.jpeg)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwMjg1NTE2MDJdfQ==
-->